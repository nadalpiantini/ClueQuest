import { createClient } from '@/lib/supabase/server';
import OpenAI from 'openai';

// AI Avatar generation styles based on mindmap requirements
export type AvatarStyle = 'realistic' | 'cartoon' | '8bit' | 'fantasy' | 'cyberpunk' | 'medieval';

// AI content types for ClueQuest
export type AIContentType = 'avatar' | 'narrative' | 'challenge' | 'hint' | 'recap';

// Avatar generation configuration
export interface AvatarGenerationConfig {
  style: AvatarStyle;
  theme?: string;
  mood?: 'adventurous' | 'mysterious' | 'playful' | 'serious';
  customPrompt?: string;
  enableModeration: boolean;
}

// Narrative generation parameters
export interface NarrativeConfig {
  theme: string;
  tone: 'adventurous' | 'mysterious' | 'educational' | 'corporate' | 'playful';
  targetAudience: 'children' | 'teens' | 'adults' | 'professionals';
  duration: 'short' | 'medium' | 'long';
  branchingPoints?: number;
  characterRoles?: string[];
}

// Challenge generation parameters
export interface ChallengeConfig {
  difficulty: 'beginner' | 'intermediate' | 'advanced' | 'expert';
  challengeType: 'trivia' | 'photo' | 'audio' | 'puzzle' | 'team';
  theme: string;
  maxAttempts: number;
  timeLimit?: number;
  educationalLevel?: string;
}

// Content moderation result
export interface ModerationResult {
  approved: boolean;
  confidence: number;
  flags: string[];
  issues: {
    violence: number;
    hate: number;
    sexual: number;
    inappropriate: number;
    bias: number;
  };
  humanReviewRequired: boolean;
}

export class AIContentService {
  private openai: OpenAI;
  private supabase: any;
  
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }
  
  async getSupabaseClient() {
    if (!this.supabase) {
      this.supabase = await createClient();
    }
    return this.supabase;
  }
  
  /**
   * Generate AI avatar from user selfie with content moderation
   */
  async generateAvatar(
    userId: string,
    sourceImageUrl: string,
    config: AvatarGenerationConfig,
    sessionId?: string
  ): Promise<{
    avatar_id: string;
    avatar_url: string;
    thumbnail_url: string;
    generation_time_seconds: number;
    moderation_result: ModerationResult;
    cost_usd: number;
  }> {
    const startTime = Date.now();
    const supabase = await this.getSupabaseClient();
    
    try {
      // Step 1: Create AI avatar record with 'generating' status
      const { data: avatarRecord, error: createError } = await supabase
        .from('cluequest_ai_avatars')
        .insert({
          user_id: userId,
          session_id: sessionId,
          source_image_url: sourceImageUrl,
          style: config.style,
          prompt_used: this.buildAvatarPrompt(config),
          ai_provider: 'openai',
          model_version: 'dall-e-3',
          status: 'generating'
        })
        .select()
        .single();
      
      if (createError) {
        throw new Error(`Failed to create avatar record: ${createError.message}`);
      }
      
      // Step 2: Generate avatar using DALL-E
      const avatarPrompt = this.buildAvatarPrompt(config);
      
      const response = await this.openai.images.generate({
        model: 'dall-e-3',
        prompt: avatarPrompt,
        size: '1024x1024',
        quality: 'standard',
        n: 1
      });
      
      if (!response.data[0]?.url) {
        throw new Error('No avatar generated by DALL-E');
      }
      
      const generatedImageUrl = response.data[0].url;
      
      // Step 3: Upload to Supabase Storage
      const imageResponse = await fetch(generatedImageUrl);
      const imageBuffer = await imageResponse.arrayBuffer();
      
      const fileName = `avatars/${userId}/${avatarRecord.id}.png`;
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('ai-generated-content')
        .upload(fileName, imageBuffer, {
          contentType: 'image/png',
          cacheControl: '3600'
        });
      
      if (uploadError) {
        throw new Error(`Failed to upload avatar: ${uploadError.message}`);
      }
      
      // Get public URL
      const { data: publicUrl } = supabase.storage
        .from('ai-generated-content')
        .getPublicUrl(fileName);
      
      // Step 4: Generate thumbnail
      const thumbnailUrl = await this.generateThumbnail(imageBuffer, userId, avatarRecord.id);
      
      // Step 5: Content moderation
      const moderationResult = await this.moderateContent(generatedImageUrl, 'avatar');
      
      // Step 6: Update avatar record with results
      const generationTimeSeconds = Math.round((Date.now() - startTime) / 1000);
      const estimatedCost = 0.08; // DALL-E 3 standard pricing
      
      const { data: updatedAvatar, error: updateError } = await supabase
        .from('cluequest_ai_avatars')
        .update({
          avatar_url: publicUrl.publicUrl,
          thumbnail_url: thumbnailUrl,
          generation_time_seconds: generationTimeSeconds,
          generation_cost: estimatedCost,
          moderation_score: moderationResult.confidence * 100,
          moderation_flags: moderationResult.flags,
          status: moderationResult.approved ? 'moderated' : 'rejected',
          approved_at: moderationResult.approved ? new Date().toISOString() : null,
          updated_at: new Date().toISOString()
        })
        .eq('id', avatarRecord.id)
        .select()
        .single();
      
      if (updateError) {
        throw new Error(`Failed to update avatar record: ${updateError.message}`);
      }
      
      // Step 7: Clean up source image for privacy
      if (sourceImageUrl.includes('temp/')) {
        await supabase.storage
          .from('temp-uploads')
          .remove([sourceImageUrl.split('/').pop()]);
      }
      
      return {
        avatar_id: avatarRecord.id,
        avatar_url: publicUrl.publicUrl,
        thumbnail_url: thumbnailUrl,
        generation_time_seconds: generationTimeSeconds,
        moderation_result: moderationResult,
        cost_usd: estimatedCost
      };
      
    } catch (error) {
      // Update record with error status
      await supabase
        .from('cluequest_ai_avatars')
        .update({
          status: 'rejected',
          updated_at: new Date().toISOString()
        })
        .eq('id', avatarRecord?.id);
      
      console.error('Avatar generation failed:', error);
      throw error;
    }
  }
  
  /**
   * Generate dynamic narrative content for adventures
   */
  async generateNarrative(
    adventureId: string,
    config: NarrativeConfig,
    sceneId?: string
  ): Promise<{
    narrative_id: string;
    narrative_text: string;
    dialogue: Array<{ character: string; text: string; }>;
    branching_options: Array<{ text: string; leads_to: string; }>;
    readability_score: number;
    cost_usd: number;
  }> {
    const supabase = await this.getSupabaseClient();
    
    try {
      // Create narrative record
      const { data: narrativeRecord, error: createError } = await supabase
        .from('cluequest_ai_narratives')
        .insert({
          adventure_id: adventureId,
          scene_id: sceneId,
          theme: config.theme,
          tone: config.tone,
          target_audience: config.targetAudience,
          prompt_parameters: config,
          ai_provider: 'openai',
          model_version: 'gpt-4',
          status: 'generating'
        })
        .select()
        .single();
      
      if (createError) {
        throw new Error(`Failed to create narrative record: ${createError.message}`);
      }
      
      // Build narrative prompt
      const narrativePrompt = this.buildNarrativePrompt(config);
      
      // Generate content using GPT-4
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'You are a creative storyteller specializing in interactive adventures. Generate engaging, appropriate content for scavenger hunts and adventure games.'
          },
          {
            role: 'user',
            content: narrativePrompt
          }
        ],
        temperature: 0.8,
        max_tokens: 1000
      });
      
      const generatedContent = response.choices[0]?.message?.content;
      if (!generatedContent) {
        throw new Error('No narrative content generated');
      }
      
      // Parse structured content
      const structuredContent = this.parseNarrativeContent(generatedContent, config);
      
      // Content moderation
      const moderationResult = await this.moderateContent(generatedContent, 'narrative');
      
      // Calculate readability score
      const readabilityScore = this.calculateReadabilityScore(structuredContent.narrative_text);
      
      // Estimate cost (GPT-4 pricing)
      const estimatedCost = (response.usage?.total_tokens || 0) * 0.00003; // $0.03 per 1K tokens
      
      // Update record with results
      const { data: updatedNarrative, error: updateError } = await supabase
        .from('cluequest_ai_narratives')
        .update({
          narrative_text: structuredContent.narrative_text,
          dialogue: structuredContent.dialogue,
          branching_options: structuredContent.branching_options,
          readability_score: readabilityScore,
          generation_cost: estimatedCost,
          moderation_passed: moderationResult.approved,
          inappropriate_content_detected: !moderationResult.approved,
          bias_score: moderationResult.issues.bias * 100,
          status: moderationResult.approved ? 'moderated' : 'rejected',
          updated_at: new Date().toISOString()
        })
        .eq('id', narrativeRecord.id)
        .select()
        .single();
      
      if (updateError) {
        throw new Error(`Failed to update narrative record: ${updateError.message}`);
      }
      
      return {
        narrative_id: narrativeRecord.id,
        narrative_text: structuredContent.narrative_text,
        dialogue: structuredContent.dialogue,
        branching_options: structuredContent.branching_options,
        readability_score: readabilityScore,
        cost_usd: estimatedCost
      };
      
    } catch (error) {
      console.error('Narrative generation failed:', error);
      throw error;
    }
  }
  
  /**
   * Generate dynamic challenges with AI
   */
  async generateChallenge(
    sceneId: string,
    config: ChallengeConfig
  ): Promise<{
    challenge_id: string;
    question_text: string;
    question_type: string;
    correct_answer: string;
    answer_options?: string[];
    validation_criteria: any;
    difficulty_score: number;
    cost_usd: number;
  }> {
    const supabase = await this.getSupabaseClient();
    
    try {
      // Generate challenge using GPT-4
      const challengePrompt = this.buildChallengePrompt(config);
      
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'You are an expert puzzle designer creating engaging challenges for scavenger hunts. Generate clear, fair, and appropriately difficult challenges. Always respond in valid JSON format.'
          },
          {
            role: 'user',
            content: challengePrompt
          }
        ],
        temperature: 0.7,
        max_tokens: 500
      });
      
      const generatedContent = response.choices[0]?.message?.content;
      if (!generatedContent) {
        throw new Error('No challenge content generated');
      }
      
      // Parse JSON response
      const challengeData = JSON.parse(generatedContent);
      
      // Content moderation
      const moderationResult = await this.moderateContent(challengeData.question_text, 'challenge');
      
      if (!moderationResult.approved) {
        throw new Error('Generated challenge failed content moderation');
      }
      
      // Create challenge record
      const { data: challengeRecord, error: createError } = await supabase
        .from('cluequest_ai_challenges')
        .insert({
          scene_id: sceneId,
          question_text: challengeData.question_text,
          question_type: challengeData.question_type,
          correct_answer: challengeData.correct_answer,
          answer_options: challengeData.answer_options || [],
          validation_criteria: challengeData.validation_criteria || {},
          time_limit: config.timeLimit || 60,
          difficulty_level: this.mapDifficultyToNumber(config.difficulty),
          ai_provider: 'openai',
          generation_prompt: challengePrompt,
          generation_cost: (response.usage?.total_tokens || 0) * 0.00003,
          human_reviewed: false,
          accuracy_verified: false
        })
        .select()
        .single();
      
      if (createError) {
        throw new Error(`Failed to create challenge record: ${createError.message}`);
      }
      
      return {
        challenge_id: challengeRecord.id,
        question_text: challengeData.question_text,
        question_type: challengeData.question_type,
        correct_answer: challengeData.correct_answer,
        answer_options: challengeData.answer_options,
        validation_criteria: challengeData.validation_criteria,
        difficulty_score: this.mapDifficultyToNumber(config.difficulty),
        cost_usd: (response.usage?.total_tokens || 0) * 0.00003
      };
      
    } catch (error) {
      console.error('Challenge generation failed:', error);
      throw error;
    }
  }
  
  /**
   * Content moderation using OpenAI moderation API
   */
  private async moderateContent(content: string, contentType: AIContentType): Promise<ModerationResult> {
    try {
      const moderation = await this.openai.moderations.create({
        input: content
      });
      
      const result = moderation.results[0];
      
      const issues = {
        violence: result.category_scores.violence,
        hate: result.category_scores.hate,
        sexual: result.category_scores.sexual,
        inappropriate: result.category_scores['self-harm'] + result.category_scores.harassment,
        bias: 0 // Would need additional bias detection service
      };
      
      const flags = Object.entries(result.categories)
        .filter(([_, flagged]) => flagged)
        .map(([category, _]) => category);
      
      const highRiskFlags = ['violence', 'hate', 'sexual'].some(category => 
        result.category_scores[category as keyof typeof result.category_scores] > 0.8
      );
      
      return {
        approved: !result.flagged && !highRiskFlags,
        confidence: 1 - Math.max(...Object.values(result.category_scores)),
        flags,
        issues,
        humanReviewRequired: result.flagged && !highRiskFlags
      };
      
    } catch (error) {
      console.error('Content moderation failed:', error);
      return {
        approved: false,
        confidence: 0,
        flags: ['moderation_error'],
        issues: {
          violence: 0,
          hate: 0,
          sexual: 0,
          inappropriate: 0,
          bias: 0
        },
        humanReviewRequired: true
      };
    }
  }
  
  /**
   * Build DALL-E prompt for avatar generation
   */
  private buildAvatarPrompt(config: AvatarGenerationConfig): string {
    const stylePrompts = {
      realistic: 'photorealistic portrait, professional quality',
      cartoon: 'cartoon style illustration, vibrant colors, friendly appearance',
      '8bit': 'pixel art style, retro gaming aesthetic, 16-bit inspired',
      fantasy: 'fantasy RPG character, magical elements, heroic pose',
      cyberpunk: 'cyberpunk aesthetic, neon accents, futuristic elements',
      medieval: 'medieval fantasy style, armor and heraldry, noble bearing'
    };
    
    const basePrompt = stylePrompts[config.style];
    const themeAddition = config.theme ? `, ${config.theme} themed` : '';
    const moodAddition = config.mood ? `, ${config.mood} expression` : '';
    
    return `${basePrompt}${themeAddition}${moodAddition}, suitable for family-friendly adventure game, high quality, centered composition${config.customPrompt ? `, ${config.customPrompt}` : ''}`;
  }
  
  /**
   * Build narrative generation prompt
   */
  private buildNarrativePrompt(config: NarrativeConfig): string {
    return `Create an engaging ${config.duration} narrative for a ${config.theme} themed interactive adventure.

Target Audience: ${config.targetAudience}
Tone: ${config.tone}
Branching Points: ${config.branchingPoints || 2}
Character Roles: ${config.characterRoles?.join(', ') || 'diverse cast'}

Requirements:
- Appropriate for ${config.targetAudience}
- ${config.tone} tone throughout
- Include ${config.branchingPoints || 2} decision points
- Create immersive but brief story segments
- Family-friendly content only
- Encourage exploration and teamwork

Format your response as JSON with:
{
  "narrative_text": "Main story text",
  "dialogue": [{"character": "Name", "text": "Dialogue"}],
  "branching_options": [{"text": "Choice text", "leads_to": "outcome"}]
}`;
  }
  
  /**
   * Build challenge generation prompt
   */
  private buildChallengePrompt(config: ChallengeConfig): string {
    return `Create a ${config.difficulty} difficulty ${config.challengeType} challenge for a ${config.theme} themed adventure.

Requirements:
- Difficulty: ${config.difficulty} (appropriate for the level)
- Type: ${config.challengeType}
- Theme: ${config.theme}
- Time limit: ${config.timeLimit || 60} seconds
- Max attempts: ${config.maxAttempts}
${config.educationalLevel ? `- Educational level: ${config.educationalLevel}` : ''}

Challenge types:
- trivia: Multiple choice or short answer questions
- photo: Photo validation challenges (describe what to photograph)
- audio: Audio-based puzzles or voice challenges
- puzzle: Logic puzzles or riddles
- team: Collaborative challenges requiring teamwork

Format your response as JSON:
{
  "question_text": "The challenge question or instruction",
  "question_type": "multiple_choice|true_false|short_answer|photo_validation|audio_recognition",
  "correct_answer": "The correct answer",
  "answer_options": ["Option 1", "Option 2", "Option 3", "Option 4"],
  "validation_criteria": {
    "case_sensitive": false,
    "accept_partial": true,
    "keywords": ["word1", "word2"]
  }
}`;
  }
  
  /**
   * Parse narrative content from AI response
   */
  private parseNarrativeContent(content: string, config: NarrativeConfig): {
    narrative_text: string;
    dialogue: Array<{ character: string; text: string; }>;
    branching_options: Array<{ text: string; leads_to: string; }>;
  } {
    try {
      const parsed = JSON.parse(content);
      return {
        narrative_text: parsed.narrative_text || content,
        dialogue: parsed.dialogue || [],
        branching_options: parsed.branching_options || []
      };
    } catch {
      // Fallback if not JSON format
      return {
        narrative_text: content,
        dialogue: [],
        branching_options: []
      };
    }
  }
  
  /**
   * Generate thumbnail from full image
   */
  private async generateThumbnail(
    imageBuffer: ArrayBuffer,
    userId: string,
    avatarId: string
  ): Promise<string> {
    // In a real implementation, you'd use an image processing service
    // For now, we'll use the same image as thumbnail
    const supabase = await this.getSupabaseClient();
    
    const thumbnailFileName = `avatars/${userId}/${avatarId}_thumb.png`;
    const { data: uploadData, error } = await supabase.storage
      .from('ai-generated-content')
      .upload(thumbnailFileName, imageBuffer, {
        contentType: 'image/png',
        cacheControl: '3600'
      });
    
    if (error) {
      throw new Error(`Failed to upload thumbnail: ${error.message}`);
    }
    
    const { data: publicUrl } = supabase.storage
      .from('ai-generated-content')
      .getPublicUrl(thumbnailFileName);
    
    return publicUrl.publicUrl;
  }
  
  /**
   * Calculate readability score for content
   */
  private calculateReadabilityScore(text: string): number {
    // Simple readability calculation (Flesch Reading Ease approximation)
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0).length;
    const words = text.split(/\s+/).filter(w => w.length > 0).length;
    const syllables = this.countSyllables(text);
    
    if (sentences === 0 || words === 0) return 0;
    
    const avgWordsPerSentence = words / sentences;
    const avgSyllablesPerWord = syllables / words;
    
    const score = 206.835 - (1.015 * avgWordsPerSentence) - (84.6 * avgSyllablesPerWord);
    
    return Math.max(0, Math.min(100, Math.round(score)));
  }
  
  /**
   * Count syllables in text (approximate)
   */
  private countSyllables(text: string): number {
    const words = text.toLowerCase().match(/\b[a-z]+\b/g) || [];
    
    return words.reduce((total, word) => {
      // Simple syllable counting heuristic
      const syllableMatch = word.match(/[aeiouy]+/g);
      let syllables = syllableMatch ? syllableMatch.length : 1;
      
      // Adjust for silent 'e'
      if (word.endsWith('e') && syllables > 1) {
        syllables--;
      }
      
      return total + Math.max(1, syllables);
    }, 0);
  }
  
  /**
   * Map difficulty level to numeric score
   */
  private mapDifficultyToNumber(difficulty: ChallengeConfig['difficulty']): number {
    const mapping = {
      beginner: 2,
      intermediate: 5,
      advanced: 7,
      expert: 9
    };
    
    return mapping[difficulty];
  }
  
  /**
   * Generate post-event recap with AI
   */
  async generateEventRecap(
    sessionId: string,
    includePlayerHighlights: boolean = true
  ): Promise<{
    recap_text: string;
    highlights: Array<{ player: string; achievement: string; }>;
    statistics: any;
    memorable_moments: string[];
  }> {
    const supabase = await this.getSupabaseClient();
    
    // Get session data for recap
    const { data: sessionData } = await supabase.rpc(
      'get_session_live_state',
      { session_id_param: sessionId }
    );
    
    if (!sessionData) {
      throw new Error('Session not found for recap generation');
    }
    
    // Build recap prompt
    const recapPrompt = `Generate an engaging recap for a completed adventure session.

Session Details:
- Adventure: ${sessionData.session?.title}
- Participants: ${sessionData.players?.length || 0}
- Completion Rate: ${sessionData.session?.completion_rate || 0}%
- Duration: ${this.formatDuration(sessionData.session?.actual_start, sessionData.session?.actual_end)}

Top Players:
${sessionData.players?.slice(0, 3).map((p: any, i: number) => 
  `${i + 1}. ${p.display_name} - ${p.total_score} points`
).join('\n') || 'No players data'}

Create a celebratory recap that:
- Acknowledges everyone's participation
- Highlights memorable moments
- Celebrates achievements without shaming lower performers
- Encourages future participation
- Maintains the adventure theme

Format as JSON:
{
  "recap_text": "Main celebratory text",
  "highlights": [{"player": "Name", "achievement": "What they did well"}],
  "memorable_moments": ["Moment 1", "Moment 2", "Moment 3"]
}`;
    
    const response = await this.openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        {
          role: 'system',
          content: 'You are a celebration specialist who creates positive, inclusive recaps of adventure events.'
        },
        {
          role: 'user',
          content: recapPrompt
        }
      ],
      temperature: 0.8,
      max_tokens: 800
    });
    
    const recapContent = JSON.parse(response.choices[0]?.message?.content || '{}');
    
    return {
      recap_text: recapContent.recap_text || 'What an amazing adventure you all completed together!',
      highlights: recapContent.highlights || [],
      statistics: {
        total_participants: sessionData.players?.length || 0,
        completion_rate: sessionData.session?.completion_rate || 0,
        total_challenges: sessionData.players?.reduce((sum: number, p: any) => sum + (p.scenes_completed || 0), 0) || 0,
        session_duration: this.formatDuration(sessionData.session?.actual_start, sessionData.session?.actual_end)
      },
      memorable_moments: recapContent.memorable_moments || []
    };
  }
  
  /**
   * Format duration between two timestamps
   */
  private formatDuration(start?: string, end?: string): string {
    if (!start || !end) return 'Unknown duration';
    
    const durationMs = new Date(end).getTime() - new Date(start).getTime();
    const minutes = Math.round(durationMs / (1000 * 60));
    
    if (minutes < 60) {
      return `${minutes} minutes`;
    } else {
      const hours = Math.floor(minutes / 60);
      const remainingMinutes = minutes % 60;
      return `${hours}h ${remainingMinutes}m`;
    }
  }
}

// Export singleton instance
export const aiContentService = new AIContentService();